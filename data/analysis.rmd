---
title: "analysis"
header-includes:
  - \usepackage{amsmath}
  - \usepackage{bm}
output:
  pdf_document: default
---

```{r setup, message = FALSE}
library(MASS)
library(broom)
library(tidyverse)
options(pillar.sigfig=4)
```

# Data import

```{r}
csv2tibble <- function(fn, show_plot = FALSE) {

  # Determine the condition of this trial
  if (grepl("-nothing", fn)) {
    condition <- "control"
  } else if (grepl("-plant", fn)) {
    condition <- "liveplant"
  } else if (grepl("-deadplant", fn)) {
    condition <- "deadplant"
  # } else if (grepl("-soil", fn)) {
  #   condition <- "soil"
  } else {
    stop("Cannot infer condition for file ", fn)
  }

  # Determine the enclosure/sensor of this trial
  if (grepl("1a", fn)) {
    sensor <- "A"
  } else if (grepl("2b", fn)) {
    sensor <- "B"
  } else if (grepl("3d", fn)) {
    sensor  <- "C"
  } else {
    stop("Cannot infer enclosure/sensor for file ", fn)
  }

  tib <- fn %>%
    { suppressMessages(
      read_csv(., col_names = c("datetime", "type", "value"))) } %>%
    # obs of type "comment" are not used
    filter(type %in% c("pm2.5", "pm10")) %>%
    mutate(value=as.numeric(value)) %>%
    mutate(
      condition=condition, sensor=sensor, fn=fn,
      has_area=condition %in% c("deadplant", "liveplant"),
      has_bio=condition == "liveplant")

  # Experiment starts when PM2.5 first drops below 900.
  first_pm2.5_999.99 <- tib %>%
    filter(type == "pm2.5" & value == 999.9) %>%
    .$datetime %>%
    last()
  first_pm2.5_sub900 <- tib %>%
    filter(datetime > first_pm2.5_999.99) %>%
    filter(type == "pm2.5" & value <= 900) %>%
    .$datetime %>%
    first()

  # Experiment ends when PM2.5/PM10 first drops below 10.
  first_sub10 <- tib %>%
    filter(datetime > first_pm2.5_sub900 & value < 10) %>%
    .$datetime %>%
    first()

  if (show_plot) {
    g <- ggplot(tib, aes(x=datetime, y=value, colour=type)) +
      geom_point() +
      geom_hline(yintercept = c(900, 999.9)) +
      geom_vline(xintercept = c(
        first_pm2.5_999.99, first_pm2.5_sub900, first_sub10))
    print(g)
  }

  tib <- filter(tib, between(datetime, first_pm2.5_sub900, first_sub10)) %>%
    # use minutes instead of seconds, otherwise will get Inf on exp later
    mutate(elapsed=as.numeric(datetime-first_pm2.5_sub900)/60)

  tib
}

# Make a list of two tibbles, one for PM2.5, the other for PM10.
data <- list.files("05-analysis-proper/", "*.csv") %>%
  Filter(function(x) !grepl("-soil", x), .) %>%
  paste0("05-analysis-proper/", .) %>%
  lapply(csv2tibble) %>%
  do.call(bind_rows, .) %>%
  mutate(
    condition=
      factor(condition, levels=c("control", "deadplant", "liveplant")),
    type=factor(type, levels=c("pm2.5", "pm10"))) %>%
  {list(
    pm2.5 = filter(., type=="pm2.5"),
    pm10 = filter(., type=="pm10")
  )}
```

Note that we omit the soil controls because 5 of 15 of those trials suffer from systematic errors, likely due to a leaky seal on the enclosure.

Sanity check:

```{r fig.retina = 2}
do.call(bind_rows, data) %>%
  filter(value > 10) %>%
  ggplot(aes(x=elapsed, y=value)) +
  geom_point(size=.1, alpha=.1) +
  facet_grid(type~condition)
```

# Model selection

Stepwise BIC optimisation reports a complex model to be most suitable for both
PM2.5 and PM10.

```{r}
model_full <- (
  value ~ elapsed*sensor + elapsed*has_area + elapsed*has_bio)
glm_bare <- glm(value ~ 1, family=Gamma("log"), data=data$pm2.5)
glm_full <- glm(model_full, family=Gamma("log"), data=data$pm2.5)
stepAIC(
  glm_bare, scope=list(lower=glm_bare, upper=glm_full),
  direction="both", trace = FALSE,
  k=log(nrow(data$pm2.5)))
```

```{r}
glm_bare <- glm(value ~ 1, family=Gamma("log"), data=data$pm10)
glm_full <- glm(model_full, family=Gamma("log"), data=data$pm10)
stepAIC(
  glm_bare, scope=list(lower=glm_bare, upper=glm_full),
  direction="both", trace = FALSE,
  k=log(nrow(data$pm10)))
```

However, we will opt for a simpler model instead, which has comparable BIC:

```{r}
model_simpler <- (
  value ~ elapsed*sensor + elapsed:has_area + elapsed:has_bio)
tibble(
  pm2.5_simpler = BIC(glm(model_simpler, family=Gamma("log"), data=data$pm2.5)),
  pm2.5_full = BIC(glm(model_full, family=Gamma("log"), data=data$pm2.5)),
  pm10_simpler = BIC(glm(model_simpler, family=Gamma("log"), data=data$pm10)),
  pm10_full = BIC(glm(model_full, family=Gamma("log"), data=data$pm10))
)
```

# Regression

## For PM2.5

```{r}
fits <- list()
fits$pm2.5 <- data$pm2.5 %>%
  glm(model_simpler, family=Gamma(link="log"), data=.)
summary(fits$pm2.5)
```

## For PM10

```{r}
fits$pm10 <- data$pm10 %>%
  glm(model_simpler, family=Gamma(link="log"), data=.)
summary(fits$pm10)
```

## Confidence interval for estimates

Since the p-values are all non-informatively small, we report the confidence intervals instead.

```{r}
coeffs <- lapply(names(fits), function(pm) {
    tidy(fits[[pm]]) %>% mutate(pm=pm)
  })
names(coeffs) <- names(fits)  # was erased
cis <- lapply(fits, confint)

stopifnot(all(coeffs$pm2.5$term == rownames(cis$pm2.5)))
stopifnot(all(coeffs$pm10$term == rownames(cis$pm10)))
stopifnot(all(names(coeffs) == names(cis)))  # in the same order

bind_cols(
  do.call(bind_rows, coeffs),
  do.call(bind_rows, lapply(cis, as_tibble))) %>%
  dplyr::select(pm, term, `2.5 %`, estimate, `97.5 %`)
```

## Effect on half-life

Let \(\lambda_1\) be the coefficient of time \(t\) under some first condition, and \(\lambda_2\) the same coefficient under a different second condition.
We can identify the marginal multiplicative effect of the second condition over the first on the half-life as follows:
\begin{align*}
  \frac{t_{1/2,\, 2}}{t_{1/2,\, 1}} &=
      \frac{\ln 2 / \lambda_2}{\ln 2 / \lambda_1} \\
    &= \frac{\lambda_1}{\lambda_2},
\end{align*}
where \(t_{1/2,\, 1}\) is the half-life under the first condition, and \(t_{1/2,\,2}\) under the second.

Note that since the half-life is a ratio of coefficient sets of a conditions, there is no easy way to factorise out the coefficients associated with the control variables.
So, we report the marginal percentage change in half-life by presence of surface area and then biological activity, once for each sensor.

```{r}
diff_hl <- function(c2, c1, pm) {
  stopifnot(pm %in% c("pm2.5", "pm10"))
  coeff <- coeffs[[pm]]
  ci <- cis[[pm]]
  stopifnot(all(c1 %in% rownames(ci)))
  stopifnot(all(c2 %in% rownames(ci)))

  lambda1s <- c1 %>%
    sapply(function(c) {
      lower <- ci[c, 1]
      est <- filter(coeff, term == c) %>% pull(estimate)
      upper  <- ci[c, 2]
      c(lower, est, upper)
    }) %>%
    t()

  lambda2s <- c2 %>%
    sapply(function(c) {
      lower <- ci[c, 1]
      est <- filter(coeff, term == c) %>% pull(estimate)
      upper  <- ci[c, 2]
      c(lower, est, upper)
    }) %>%
    t()

  apply(lambda1s, 2, sum) / apply(lambda2s, 2, sum)
}

hl_design <- tibble(
  pm = c(rep("pm2.5", 6), rep("pm10", 6)),
  effect_of = rep(c(rep("area", 3), rep("bio", 3)), 2),
  sensor = rep(c("A", "B", "C"), 4)
)
hl_effects <- apply(hl_design, 1, function(row) {
    pm <- row[1];  effect_of <- row[2];  sensor <- row[3]
    stopifnot(pm %in% c("pm2.5", "pm10"))
    stopifnot(effect_of %in% c("area", "bio"))
    stopifnot(sensor %in% c("A", "B", "C"))
  
    # Construct c1
    c1 <- "elapsed"
    if (sensor == "B") c1 <- c(c1, "elapsed:sensorB")
    if (sensor == "C") c1 <- c(c1, "elapsed:sensorC")
    if (effect_of == "bio") c1 <- c(c1, "elapsed:has_areaTRUE")
  
    # Construct c2
    if (effect_of == "area") c2 <- c(c1, "elapsed:has_areaTRUE")
    if (effect_of == "bio") c2 <- c(c1, "elapsed:has_bioTRUE")
  
    diff_hl(c2, c1, pm)
  }) %>%
  t() %>%
  as.data.frame()

bind_cols(hl_design, hl_effects) %>%
  mutate(lower=V1, estimate=V2, upper=V3) %>%
  dplyr::select(-V1, -V2, -V3)
```

# Visualisation

## Pre-computation

For the purpose of visualization, we first 'normalize' readings by factoring out sensor effects.
The resulting value is named the \texttt{sc_value}, as in sensor-normalized value.

```{r}
pm2.5_glm.tb <- tidy(fits$pm2.5)

sensorB_coeff <- pm2.5_glm.tb %>%
  filter(term == "sensorB") %>%
  .$estimate
sensorC_coeff <- pm2.5_glm.tb %>%
  filter(term == "sensorC") %>%
  .$estimate
sensorB_int_coeff <- pm2.5_glm.tb %>%
  filter(term == "elapsed:sensorB") %>%
  .$estimate
sensorC_int_coeff <- pm2.5_glm.tb %>%
  filter(term == "elapsed:sensorC") %>%
  .$estimate

data$pm2.5 <- data$pm2.5 %>%
  mutate(sc_value=recode(
    sensor,
    A=value,
    B=value / exp(sensorB_coeff + sensorB_int_coeff*elapsed),
    C=value / exp(sensorC_coeff + sensorC_int_coeff*elapsed)
  ))

data$pm2.5 %>%
  ggplot(aes(x=elapsed)) +
  geom_point(aes(y=value), size=.1, alpha=.1) +
  geom_point(aes(y=sc_value), size=.1, alpha=.1, colour="red") +
  facet_grid(~sensor)
```

Repeat for PM10.

```{r}
pm10_glm.tb <- tidy(fits$pm10)

sensorB_coeff <- pm10_glm.tb %>%
  filter(term == "sensorB") %>%
  .$estimate
sensorC_coeff <- pm10_glm.tb %>%
  filter(term == "sensorC") %>%
  .$estimate
sensorB_int_coeff <- pm10_glm.tb %>%
  filter(term == "elapsed:sensorB") %>%
  .$estimate
sensorC_int_coeff <- pm10_glm.tb %>%
  filter(term == "elapsed:sensorC") %>%
  .$estimate

data$pm10 <- data$pm10 %>%
  mutate(sc_value=recode(
    sensor,
    A=value,
    B=value / exp(sensorB_coeff + sensorB_int_coeff*elapsed),
    C=value / exp(sensorC_coeff + sensorC_int_coeff*elapsed)
  ))

data$pm10 %>%
  ggplot(aes(x=elapsed)) +
  geom_point(aes(y=value), size=.1, alpha=.1) +
  geom_point(aes(y=sc_value), size=.1, alpha=.1, colour="red") +
  facet_grid(~sensor)
```

## Final graph

```{r}
data %>%
  do.call(bind_rows, .) %>%
  mutate(
    type=factor(
      ifelse(type == "pm2.5", "PM[2.5]", "PM[10]"),
      levels=c("PM[2.5]", "PM[10]")),
    # `~` represent spaces when parsed by ggplot:label_parsed
    condition=recode(
      condition,
      control = "Control",
      deadplant = "Dead~plant",
      liveplant = "Live~plant"
    )) %>%
  ggplot(aes(x=elapsed, y=sc_value)) +
  geom_point(
    data=bind_rows(data) %>%
      dplyr::select(-condition) %>%
      mutate(type=factor(
        ifelse(type == "pm2.5", "PM[2.5]", "PM[10]"),
        levels=c("PM[2.5]", "PM[10]"))),
    aes(x=elapsed, y=sc_value),
    size=.2, alpha=.05
  ) +
  geom_point(aes(fill=condition, colour=condition), size=.2, shape=21) +
  facet_grid(type ~ condition, labeller=label_parsed) +
  theme(legend.position = "none") +
  ylab(expression("PM Concentration ("*mu*"g m"^-3*")")) +
  xlab(expression("Time (mins)"))

ggsave("concentration-time.eps", device=cairo_ps, width=9, height=6, units="in")
```
